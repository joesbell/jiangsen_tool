# 类

## super 关键字 既可以当函数用也可以当对象用

_第一种情况，super 作为函数时候，代表父类的构造函数_

```
class a{

}
class b extends a{
  constructor() {
    super();//相当于a.prorotype.constructor.call(this)。这里的This指向b.

  }

}
```

_第二种情况 super 作为对象使用_

```
class a{
  p(){
    return 2
  }
}
class b extends a{
  constructor(){
    super()//代表父类的构造函数
    console.log(super.p());//指向父类的原型对象，a.prototype.p()

  }
}

```

---

_因为 super.xxx 指向的是父类的原型对象，所以父类实例（即父类 constroctor 中的）上的属性或者方法，并不能通过 super 调用。_

## super 作为对象，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。同时，在普通方法中的 this 是指向子类的实例。在静态方法中 this 指向子类本身。

```
class a {
  constructor(public x: number) {
    this.x = 1;
  }
  say() {
    console.log(this.x);
  }
}
class B extends a {
  constructor() {
    super(1);
    this.x = 2;
  }
  sayx() {
    super.say(); //相当于a.prototype.say.call(this)
  }
}
let b = new B();
b.sayx();//2
```

## static 静态方法，是不需要实例化去调用的方法，即该方法是挂在构造函数内而不是原型对象上

```
class a {
  static x() {
    console.log(1111);
  }
}
a.x();

```

## private, protected public

## public 允许在类的内外被调用

```
class Person {
  public name: string = 'jiangsen';
  sayHi() {
    console.log(this.name);
  }
}
const person = new Person();
console.log(person.name);
```

## private 只允许在类中使用

```
class Person1 {
  private name: string = 'hello';
}
const person = new Person1();
console.log(person.name);//只能在类中调用
```

## protected 允许在类中使用同时可以在继承的子类中使用

```
class Person1 {
  protected name: string = 'hello';
}
const person = new Person1();

class son extends Person1 {
  public say() {
    console.log(this.name);
  }
} //可以在继承的子类中调用
```

### class 写法

```
class Tree {
  // 传统写法
  // public name:string;
  // constructor(name:string){
  //   this.name=name;
  // }

  // 简化写法
  constructor(public name: string) {}
}
const tree = new Tree('jiangsen');
console.log(tree.name);
```

---

## getter setter

```
class conObj {
  constructor(private name: string) {}
  get getName() {
    return this.name + 'lee';
  }
  set setName(name: string) {
    const realName = name.split(' ')[0];
    this.name = realName;
  }
}
const newObj = new conObj('dell');
console.log(newObj.getName); //getter  取值  delllee
newObj.setName = 'dell111 lee'; //settet 设置值 dell111lee
console.log(newObj.getName);
```

## 单例模式

```
class Single {
  private static instance: Single;
  private constructor(public name: string) {}
  static getInstance() {
    if (!this.instance) {
      this.instance = new Single('jiangsen');
    }
    return this.instance;
  }
}
const demo1 = Single.getInstance();

const demo2 = Single.getInstance();
console.log(demo1 === demo2);

```

## 抽象类 提取几个类的公共方法

```
abstract class Gemo {
  abstract getArea(): number;
}
// new Gemo()//抽象类不能实例化 只能继承
class a extends Gemo {
  getArea(): number {
    return 1334;
  }
}


```
