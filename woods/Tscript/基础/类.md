# 类

## super关键字 既可以当函数用也可以当对象用
*第一种情况，super作为函数时候，代表父类的构造函数*
```
class a{

}
class b extends a{
  constructor() {
    super();//相当于a.prorotype.constructor.call(this)。这里的This指向b.

  }

}
```

*第二种情况 super作为对象使用*
```
class a{
  p(){
    return 2
  }
}
class b extends a{
  constructor(){
    super()//代表父类的构造函数
    console.log(super.p());//指向父类的原型对象，a.prototype.p()

  }
}

```
----
*因为super.xxx指向的是父类的原型对象，所以父类实例（即父类constroctor中的）上的属性或者方法，并不能通过super调用。*
## super 作为对象，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。同时，在普通方法中的this是指向子类的实例。在静态方法中this指向子类本身。
```
class a {
  constructor(public x: number) {
    this.x = 1;
  }
  say() {
    console.log(this.x);
  }
}
class B extends a {
  constructor() {
    super(1);
    this.x = 2;
  }
  sayx() {
    super.say(); //相当于a.prototype.say.call(this)
  }
}
let b = new B();
b.sayx();//2
```


## static 静态方法，是不需要实例化去调用的方法，即该方法是挂在构造函数内而不是原型对象上
```
class a {
  static x() {
    console.log(1111);
  }
}
a.x();

```

## private, protected public
## public 允许在类的内外被调用
```
class Person {
  public name: string = 'jiangsen';
  sayHi() {
    console.log(this.name);
  }
}
const person = new Person();
console.log(person.name);
```


## private 只允许在类中使用
```
class Person1 {
  private name: string = 'hello';
}
const person = new Person1();
console.log(person.name);//只能在类中调用
```


## protected 允许在类中使用同时可以在继承的子类中使用
```
class Person1 {
  protected name: string = 'hello';
}
const person = new Person1();

class son extends Person1 {
  public say() {
    console.log(this.name);
  }
} //可以在继承的子类中调用
```

### class写法
```
class Tree {
  // 传统写法
  // public name:string;
  // constructor(name:string){
  //   this.name=name;
  // }

  // 简化写法
  constructor(public name: string) {}
}
const tree = new Tree('jiangsen');
console.log(tree.name);
```
----
## getter  setter


